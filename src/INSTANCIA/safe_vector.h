/*
    Modificado por Igor de Andrade Junqueira,
    comentario original:

    Safe C++, Or How to Avoid Most Common Mistakes in C++ Code by Vladimir Kushnir, (OÃ•Reilly).
    Copyright 2012 Vladimir Kushnir, ISBN 9781449320935.
    If you feel your use of code examples falls outside fair use or the
    permission given above, feel free to contact us at permissions@oreilly.com.
*/

#ifndef TTP_SAFE_VECTOR_H
#define TTP_SAFE_VECTOR_H

#include "iostream"
#include <vector>
#include <ostream>

// Wrapper around std::vector, has temporary sanity checks in the operators [].
template <typename T>
class Vector : public std::vector<T>
{
public:

    // Most commonly used constructors:
    explicit Vector(): std::vector<T>(){}
    explicit Vector(size_t n): std::vector<T>(n){}
    explicit Vector(const std::vector<T> &vet): std::vector<T>(vet){}
    explicit Vector(std::vector<T> &vet): std::vector<T>(vet){}

    Vector(size_t n, const T& value): std::vector<T>(n, value){}

    template <class InputIterator> Vector (InputIterator first, InputIterator last): std::vector<T>(first, last){}

    // Note: we do not provide a copy-ctor and assignment operator.
    // we rely on default versions of these methods generated by the compiler.

    inline __attribute__((always_inline)) T& operator[](size_t index)
    {
#if VAR_VECTOR_SANITY_CHECK
        if(index >= std::vector<T>::size())
        {
            std::cout<<"Erro indice "<<index<<" esta errado para vetor de tam "<<std::vector<T>::size()<<"\n";
            throw std::out_of_range("");
        }
#endif
        return (std::vector<T>::operator[](index));
    }
    inline __attribute__((always_inline)) const T& operator[](size_t index) const
    {
#if VAR_VECTOR_SANITY_CHECK
        if(index >= std::vector<T>::size())
        {
            std::cout<<"ERRO!\n";
            throw "ERRO";
        }
#endif
        return std::vector<T>::operator[](index);
    }

    void setAll(const T& val)
    {
        for(size_t i=0; i < std::vector<T>::size(); ++i)
            std::vector<T>::operator[](i) = val;
    }
};

template <typename T>
inline __attribute__((always_inline)) std::ostream& operator << (std::ostream& os, const Vector<T>& v)
{
    for(unsigned i=0; i<v.size(); ++i) 
    {
        os << v[i];
        if(i + 1 < v.size())
            os << " ";
    }

    return os;
}

#endif //TTP_SAFE_VECTOR_H
