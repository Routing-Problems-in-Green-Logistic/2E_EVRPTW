/*
    Modificado por Igor de Andrade Junqueira,
    comentario original:

    Safe C++, Or How to Avoid Most Common Mistakes in C++ Code by Vladimir Kushnir, (OÃ•Reilly).
    Copyright 2012 Vladimir Kushnir, ISBN 9781449320935.
    If you feel your use of code examples falls outside fair use or the
    permission given above, feel free to contact us at permissions@oreilly.com.
*/

#ifndef TTP_SAFE_MATRIX_H
#define TTP_SAFE_MATRIX_H

#include "iostream"
#include <vector>
#include <ostream>

// Wrapper around std::vector, has temporary sanity checks in the operators [].
template <typename T>
class Matrix : public std::vector<T>
{
public:

    // Most commonly used constructors:
    explicit Matrix(size_t n_ = 0, size_t m_=0): std::vector<T>(n_*m_), n(n_), m(m_){}

    Matrix(size_t n_, size_t m_, const T& value): std::vector<T>(n_*m_, value), n(n_), m(m_){}

//    template <class InputIterator> Vector (InputIterator first, InputIterator last): std::vector<T>(first, last){}

    // Note: we do not provide a copy-ctor and assignment operator.
    // we rely on default versions of these methods generated by the compiler.

    inline __attribute__((always_inline)) T& operator[](size_t index) = delete;
    inline __attribute__((always_inline)) const T& operator[](size_t index) const = delete;

    inline __attribute__((always_inline)) T& operator()(const size_t indexI, const size_t indexJ)
    {
#if VAR_VECTOR_SANITY_CHECK
        if(indexI >= n)
        {
            std::cout<<"Erro indice i: "<<indexI<<" esta errado para matrix de tam "<<n<<" x "<<m<<"\n";
            throw std::out_of_range("");
        }


        if(indexJ >= m)
        {
            std::cout<<"Erro indice j: "<<indexJ<<" esta errado para matrix de tam "<<n<<" x "<<m<<"\n";
            throw std::out_of_range("");
        }
#endif
        return std::vector<T>::operator[](indexI*m+indexJ);
    }

    inline __attribute__((always_inline)) const T& operator()(const size_t indexI, const size_t indexJ) const
    {
#if VAR_VECTOR_SANITY_CHECK
        if(indexI >= n)
        {
            std::cout<<"Erro indice i: "<<indexI<<" esta errado para matrix de tam "<<n<<" x "<<m<<"\n";
            throw std::out_of_range("");
        }

        if(indexJ >= m)
        {
            std::cout<<"Erro indice j: "<<indexJ<<" esta errado para matrix de tam "<<n<<" x "<<m<<"\n";
            throw std::out_of_range("");
        }
#endif
        return std::vector<T>::operator[](indexI * m + indexJ);

    }

    [[nodiscard]] size_t inline __attribute__((always_inline)) getNumLinhas() const
    {
        return n;
    }


    [[nodiscard]] size_t inline __attribute__((always_inline)) getNumColunas() const
    {
        return m;
    }

    void setVal(const T &val)
    {
        for(int i=0; i < m*n; ++i)
            std::vector<T>::operator[](i) = val;
    }

    void setVal(const T &&val)
    {
        for(int i=0; i < m*n; ++i)
            std::vector<T>::operator[](i) = val;
    }


    inline __attribute__((always_inline)) auto getIterator(const size_t indexI, const size_t indexJ)
    {
#if VAR_VECTOR_SANITY_CHECK
        if(indexI >= n)
        {
            std::cout<<"Erro indice i: "<<indexI<<" esta errado para matrix de tam "<<n<<" x "<<m<<"\n";
            throw std::out_of_range("");
        }


        if(indexJ >= m)
        {
            std::cout<<"Erro indice j: "<<indexJ<<" esta errado para matrix de tam "<<n<<" x "<<m<<"\n";
            throw std::out_of_range("");
        }
#endif
        return (std::vector<T>::begin()+(indexI*m+indexJ));
    }

private:

    size_t n=0;
    size_t m=0;

};


template <typename T>
inline __attribute__((always_inline)) std::ostream& operator << (std::ostream& os, Matrix<T>& mat)
{
    std::cout<<"operator <<\n";
    for(size_t i=0; i < mat.getNumLinhas(); ++i)
    {
        for(size_t j=0; j < mat.getNumColunas(); ++j)
        {
            const T &val = mat(i, j);
            os<<val<<" ";

        }

        os<<"\n";
    }

    return os;
}


#endif //TTP_SAFE_VECTOR_H
